# RamStockAlerts Copilot Instructions
- Money-touching IBKR order-flow system; follow hard rules in [.github/instructions/Global rules.instructions.md](.github/instructions/Global%20rules.instructions.md): smallest correct change, add observability (logs + journal), avoid magic defaults, no unrelated refactors.
- Runtime modes in [Program.cs](Program.cs): `MODE=record` runs IBKR recorder to JSONL, `MODE=replay` runs deterministic replay, `Report:DailyRollup=true` runs the rollup tool, otherwise hosts the API. `TradingMode=Shadow` (default) enables shadow journal + gate logic; `Execution:Enabled` toggles the execution module (Fake broker only today).
- Persistence: SQLite by default, PostgreSQL when `UsePostgreSQL=true`; event store is file-based unless Postgres is enabled. AppInsights optional via `ApplicationInsights:ConnectionString`.
- Universe pipeline (authoritative in [Authoritative System Policy.md](Authoritative%20System%20Policy.md) and [Depth Evaluation Window Policy](%23%20RamStockAlerts%20%E2%80%93%20Depth%20Evaluation%20Wind.md)): CandidateSet -> EligibleSet (classification) -> ProbeSet (L1/tape) -> EvalSet (depth + tick-by-tick, max 3 slots). ActiveUniverse = EvalSet that passes gates; never fire strategy outside ActiveUniverse.
- Subscription manager ([Services/MarketDataSubscriptionManager.cs](Services/MarketDataSubscriptionManager.cs)): applies universe snapshots, enforces caps (`MarketData:MaxLines`, `MaxDepthSymbols`, `TickByTickMaxSymbols`), tracks depth/tick cooldowns, logs subscription stats, and emits `UniverseUpdate` journal entries after each apply. Upgrades must preserve existing L1 request ids; depth is temporary and subject to cooldown.
- Depth evaluation windows ([Depth Evaluation Window Policy](%23%20RamStockAlerts%20%E2%80%93%20Depth%20Evaluation%20Wind.md)): upgrade only probes, bound each evaluation (timeout or exit on signal/invalid data), cancel depth+tbt on exit, log evaluation outcome; bugs if depth lives past window or exceeds slot limit.
- Tape freshness is gated on local receipt time, not exchange timestamps (see [Authoritative System Policy.md](Authoritative%20System%20Policy.md)); store both recv and event times plus skew in metrics/logs.
- Shadow trading loop ([Services/ShadowTradingCoordinator.cs](Services/ShadowTradingCoordinator.cs)): drops snapshots not in ActiveUniverse, throttles evaluations per symbol, gates on book validity and tape freshness, then uses `OrderFlowMetrics` + `OrderFlowSignalValidator` for decisions. Rejections/accepts are journaled with SchemaVersion=2 snapshots (depth/tape context, depth deltas, gate trace, blueprint when recorded).
- Journaling ([Services/ShadowTradeJournal.cs](Services/ShadowTradeJournal.cs) and [Models/ShadowTradeJournalEntry.cs](Models/ShadowTradeJournalEntry.cs)): SchemaVersion=2, deterministic JSONL at `ShadowTradeJournal:FilePath` (default logs/shadow-trade-journal.jsonl). `UniverseUpdate` entries capture candidates/ActiveUniverse/exclusions ([README/UniverseUpdateJournalEntry.md](README/UniverseUpdateJournalEntry.md)); gate rejections may include `GateTrace` ([README/GateTrace_Schema.md](README/GateTrace_Schema.md)). Keep schemas versioned and monotonic timestamps.
- Universe sources ([Universe/UniverseService.cs](Universe/UniverseService.cs)): `Universe:Source` = Static or IbkrScanner; scanner flow classifies symbols via `DepthUniverseFilter` and falls back to prior universe on failure. Legacy Polygon/Alpaca builder lives in [Engine/UniverseBuilder.cs](Engine/UniverseBuilder.cs) (kept for legacy/scanner-free paths).
- Execution module (API doc [README/EXECUTION_API.md](README/EXECUTION_API.md)): disabled by default; Fake broker only; endpoints return 503 when disabled. Risk caps via `Execution:MaxNotionalUsd` and `MaxShares`; Live mode requires stop-loss in brackets.
- Metrics/validators: `OrderFlowMetrics` computes queue imbalance, wall persistence, depth deltas, tape velocity, VWAP reclaim; `OrderFlowSignalValidator` scores signals and applies spoof/replenishment/absorption guards. Scarcity controller enforces 3–6 quality signals/day; use rising-edge style triggers to avoid signal spam.
- Observability: prefer structured Serilog logs (console + rolling files). Journal is primary artifact for replay/analysis; ensure new fields are populated or explicitly null and bump schema when changing shape. Log evaluation counts (candidates/probe/eval/active) each cycle per policy.
- IBKR feed handling: depth eligibility and error 10092 are mitigated via `DepthEligibilityCache` and `HandleIbkrError` (see [README/Runbooks.md](README/Runbooks.md)); tick-by-tick slots capped by `MarketData:TickByTickMaxSymbols`, track cooldowns and pending cancels in the subscription manager.
- Recorder/replay: `MODE=record` captures IBKR depth/tape to logs/ibkr-*.jsonl; `MODE=replay` reconstructs state deterministically for debugging. Confirm `Ibkr:*` host/port/clientId/symbol/depth rows before recording.
- Common configs: `MarketData:EnableDepth/EnableTape`, `MarketData:DepthRows`, `Ibkr:*` connection, `ShadowTradeJournal:EmitGateTrace`, `RecordBlueprints`, `AlertsEnabled`, `Execution:*`. Avoid silent fallbacks—log when defaulting.
- Build/test: `dotnet build RamStockAlerts.sln -c Debug` (task available), `dotnet test RamStockAlerts.sln` for all projects. Run API locally via `dotnet run --project RamStockAlerts.csproj`. Recorder/replay share the same binary; set env vars before launch.
- Change pattern: keep changes minimal, guarded by config, and covered by deterministic unit tests in `RamStockAlerts.Tests` / `RamStockAlerts.Execution.Tests`. When touching market data or journaling, add/update tests for schema and gate behavior and include manual verification steps if integration paths are hard to automate.
- Safety checks before merging: depth slots ≤ configured max, ActiveUniverse only, tape staleness gates on receipt time, journal SchemaVersion correct, evaluation windows start/stop logged, execution endpoints respect enabled flag and risk limits.
